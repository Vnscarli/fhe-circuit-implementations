

# This file was *autogenerated* from the file less_equal.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2000 = Integer(2000); _sage_const_160 = Integer(160); _sage_const_15 = Integer(15); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1)
load('DGHV.sage')

gamma, eta, rho = _sage_const_2000 , _sage_const_160 , _sage_const_15 
dghv = DGHV(gamma, eta, rho)

def less_equal_homomorphic(dghv, n=_sage_const_3 ):
    m0 = ZZ.random_element(_sage_const_0 , _sage_const_2 **n)
    m1 = ZZ.random_element(_sage_const_0 , _sage_const_2 **n)
    print(f"{m0} <= {m1}?")

    # Bits inverted, presented from MSB to LSB
    bits0 = m0.digits(base=_sage_const_2 , padto=n)[::-_sage_const_1 ] 
    bits1 = m1.digits(base=_sage_const_2 , padto=n)[::-_sage_const_1 ]
    
    c0 = [dghv.enc(b) for b in bits0]
    c1 = [dghv.enc(b) for b in bits1]

    #Acumulators
    is_less = dghv.enc(_sage_const_0 )
    is_equal = dghv.enc(_sage_const_1 )

    for i in range(n):
        # bit_a < bit_b: (NOT a) AND b
        # If a = 0 and b = 1 b is bigger
        # When the first bit for it to happen we know a<b
        lt_i = dghv.mult(dghv.not_gate(c0[i]), c1[i])
        
        # bit_a == bit_b: NOT (a XOR b)
        eq_i = dghv.not_gate(dghv.add(c0[i], c1[i]))

        # is_less = is_less OR (is_equal_previous AND lt_i)
        # For a<b, every bit analysed before has to be equal 
        term = dghv.mult(is_equal, lt_i)

        # Check the first time a bit in a is less than in b (a<b)
        is_less = dghv.add(is_less, term) 

        # Change to 0 if bit a != bit b
        is_equal = dghv.mult(is_equal, eq_i)

    # Answer: (A < B) OR (A == B)
    # Add is_less and is_equal to verify
    res_le = dghv.add(is_less, is_equal)
    
    dec_res = dghv.dec(res_le)
    print(f"Answer decrypted: {dec_res}")
    assert (m0 <= m1) == dec_res

less_equal_homomorphic(dghv, n=_sage_const_3 )

